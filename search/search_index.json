{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pydre documentation","text":""},{"location":"#goals","title":"Goals","text":"<p>Pydre is a software package designed to analyze driving data taken from driving simulation research studies. Specifically, it was built around the data file format generated by SimObserver, which is software sold by Realtime Technolgies for recording data from their SimObserver simulation system. </p> <p>SimObserver collects information during the simulation drive, such as vehicle speed and following distance.  This information is collected every 1/60th of a second, which results in tens of thousands of rows for a study session. Experimenters are often interested in specific metrics that look at trends, averages or other quantities that are determined by looking at longer periods of time. Processing a large experimental dataset into a smaller file of quantified metrics is what Pydre was designed to do. </p> <p>Pydre takes a drive data file with data that is difficult to interpret in raw form and applies filters and metrics to create a file that can be more easily used for statistical analysis in R (or other similar tools).</p>"},{"location":"#structure","title":"Structure","text":"<p>Pydre works by reading in <code>.dat</code> files (creating DriveData objects), then applying filters, region of interest splitters and metrics to each one.</p> <p></p>"},{"location":"#filters","title":"Filters","text":"<p>Filters add or modify data in DriveData objects, creating new columns or smoothing data. They are used to number events that are represented by binary values, convert eye tracking data into fixations or to create divisions in the data for use in region of interest processing. The augmented drive data object is passed along the pipeline in place of the original one. The order of the filters matter: the filters give their output data to the next filter in the list.</p>"},{"location":"#region-of-interest-roi-divisions","title":"Region of interest (ROI) divisions","text":"<p>Regions of interest (ROIs) represent different partitions of the data where the same metrics are applied on every partition. This is useful in processing a within-subjects or repeated measures experiment where multiple events happen in the same drive. For example, multiple obstacle interactions or testing driver distraction while performing different in-vehicle tasks would both be good examples of ROI usage. </p> <p>ROIs can be defined in terms of spatial areas, regions of time, or columns. Using data columns is the most controllable version of ROIs, and a new DriveData object is created consisting of the rows that match each unique element of that column. For example, if a column <code>Task</code> had values of <code>[2, 2, 2, 3, 3, 2]</code>, two DriveData objects would be created: one with all the rows where the <code>Task</code> value is 2 and one with all the rows with the <code>Task</code> value is 3.</p>"},{"location":"#metrics","title":"Metrics","text":"<p>Metrics create summary statistics from DriveData objects. They do not change the content of the object, but return values like the mean of a particular column or the response time of breaking after a certain event. A single metric can return one or more summary statistics. All the metric outputs for each ROI for each <code>.dat</code>  input file create one row of the output file. </p>"},{"location":"#project-files","title":"Project Files","text":"<p>Project files are JavaScript Object Notation (json) marked-up files that dictate things like which region of interest (ROI) should be tested and which metrics should be gathered. A project file should consist of two main parts: the rois array and the metrics array. Each element of the rois array should have a field to tell which type of ROI the element is (rect or time) and a corresponding file name with a path to a csv file with the relevant information for a region. Time and Space are currently the only two ROI types implemented. Their formats are detailed below. </p> <p>As for metrics, the array should consist of elements containing every function that you wish to analyze. There are a minimum of two required fields: \"name\" and \"function\". \"Name\" is the column header for the metric in the output file and \"function\" is the name of the function you wish to call in Pydre. Then, any arguments required for the function must be specified. </p> <p>Multiple functions can be called within one project file.  The result of each function will be outputted in a separate column of the generated csv file.</p> <p>To see an example project file, look at bushman_pf.json in the docs directory of the pydre folder.    </p>"},{"location":"developernotes/","title":"pydre/core.py","text":"<p>This script contains code that is intergral to the pydre module</p>"},{"location":"developernotes/#drivedata","title":"DriveData","text":"<p>This is the unit of data storage for the module. Each DriveData object contains a singular SubjectID, a list of DriveIDs, a single (optional) region of interest, a list of Pandas DataFrames created from the associated.dat files, and a list of the source file names. </p> <ul> <li>SubjectID: Unique identifier for this object. Any file loaded into a DriveData object should ONLY be data from this subject number, however, this is not currently enforced</li> <li>DriveID: List of all of the drive ids for each DataFrame in the DriveData object</li> <li>roi: Singular string denoting the region of interest of the particular DriveData. There can currently only be one region of interest per DriveData object</li> <li>data: List of the DataFrames corresponding to each drive from the DriveIDs</li> <li>sourcefilename: The names of each source file used in the data argument</li> </ul>"},{"location":"developernotes/#slicebytime","title":"<code>SliceByTime()</code>","text":"<p>This is a simple helper method to take a particular data frame and trim it to only entries that fall within a given range of times.</p>"},{"location":"developernotes/#mergebyspace","title":"<code>MergeBySpace()</code>","text":"<p>This is a utility to merge an ordered list of DriveData objects based on the point where the beginning of the next is closest (by X,Y position) to the end of the most previous DataFrame. The input should all be from the same subject, same region of interest, and should go in a logical order. The output will be a DriveData object with one element in the data list. The drive IDs and source file names of the outputted DriveData object will simply be an aggregation of all drive IDs and source files from the input list.</p>"},{"location":"developernotes/#pydreprojectpy","title":"pydre/project.py","text":"<p>This is where the processing actually takes place. The only functions that should be called outside of the project.py class are <code>__init(projectfilename)__</code>, <code>run(datafiles)</code>, and <code>save(outfilename)</code>. The basic idea is that \"init\" will load the json projectfile, \"run\" will convert all of the datafiles into DriveData objects and do all of the processing specified in the json file, and \"save\" will write all of the results to a csv file. For further details, investigate the project.py script.</p>"},{"location":"mergetool/","title":"Merge Tool","text":"<p>Merge Tool is a program designed to effectively merge SimObserver data in the event that a participant's drive is interrupted. This often occurs due to study interruptions such as SimCreator shut downs. Merge Tools is run on these separate data files from the same participant's drives and merges them into one file to ensure a uniform presentation of the data. </p> <p>For example, if during a study, called 'ExampleProject', Participant 3's original drive 1 was interrupted prematurely two times, there would be 3 separate data files created, with different drive IDs. These  drive files could be merged to create a single drive file for further processing.</p>"},{"location":"mergetool/#merge-types","title":"Merge Types","text":"<p>Merge Tool has two different kinds of merge options. This section will highlight each of them.</p>"},{"location":"mergetool/#sequential","title":"Sequential","text":"<p>Sequential Merge is a file merge based on time. Once all the files in the  <code>merge directory (-d)</code> have been processed by the program, Merge Tool will use the SimCreator's recorded <code>SimTime</code> metric to concatenate the files. This is accomplished by iterating  through every <code>SimTime</code> column, reading the last <code>SimTime</code> value of the current data file, and adding that value as a constant through the next data file's <code>SimTime</code> column. </p>"},{"location":"mergetool/#spatial","title":"Spatial","text":"<p>Spatial Merge is a file merge based on X &amp; Y coordinate positions. Much like the <code>Sequential</code>    merge, Spatial Merge will perform the same <code>SimTime</code> corrections as multiple drives for the same participant are merged.    However, along with the time correction, Spatial Merge also analyzes SimCreator's recorded <code>XPos</code> and <code>YPos</code> metrics.    <code>out_frame</code> is the variable name in which all the merged data will end up, before a csv is created. For every     <code>next_frame</code> (files that comes after the first for the participant), the row with the minimum distance from the     last position in <code>out_frame</code> will be the starting index of the data that is appended to <code>out_frame</code>.</p>"},{"location":"mergetool/#usage","title":"Usage","text":"<p>This section covers how Merge Tool is executed as well as the command line parameters that the user is expected to supply.    - Command Line execution         - Ran from where pydre is ran from         - Ex: <code>python pydre_merge.py -d 'exampleMergeDirectory' -t 'spatial or sequential'</code>    - Two Args.          1. -d (DataFile directory). The directory to be merged, is occupied by multiple drives for at least one participant.         2. -t (Merge Type). Chosen as either \"Spatial\" or \"Sequential\", determines which type of merge will be performed.</p>"},{"location":"mergetool/#testing","title":"Testing","text":"<p>Within the <code>pydre</code> folder, there will be a <code>test</code> directory with a sub-directory called  <code>MergeTools</code>. This sub-directory contains all the materials for testing <code>pydre_merge.py</code>. To run the tests, navigate to the pydre module directory (top level) and use the command: <code>python -m unittest tests\\MergeTools\\test_merge.py</code>. </p>"},{"location":"mergetool/#testing-explanation","title":"Testing Explanation","text":"<ul> <li> <p>There are two, primary functions to test within <code>merge_tool.py</code>, one for each merge            type (<code>Sequential</code> and <code>Spatial</code>). These two functions are found at (considering            <code>pydre.merge_tool</code> as <code>p_merge</code>) <code>p_merge.MergeTool.sequential_merge()</code> and            <code>p_merge.MergeTool.spatial_merge()</code>(see <code>Overview</code> above for merge-type            explanations).</p> </li> <li> <p>To properly test each of these, the testing functions must supply the two,           required parameters without using the command line (refer to <code>Usage</code> above).           Briefly, below will address how each argument is supplied in the testing. </p> </li> <li> <p>Merge Directory (-d) - Within <code>MergeTools\\test_dats_to_merge\\</code> there are a host of  directories. Each of these directories is unique per test case and will contain particular data files to simulate the  intended use of the program.</p> </li> <li> <p>Merge Type (-t) - Supplied as a string within the test case, unique to the target  <code>MergeTool()</code> function of the current test.</p> </li> </ul>"},{"location":"mergetool/#results-and-expected","title":"Results and Expected","text":"<p>This section will cover the results from running the program, the expected results, and how the two will be compared for the sake of testing.</p> <p>Results:</p> <p>After calling the target function (either <code>Sequential</code> or <code>Spatial</code>) with the two parameters from the test case, the program, after running successfully, will create a <code>.csv</code> file per participant found in the <code>Merge Directory (-d)</code>. This <code>.csv</code> file(s) can always be found in <code>MergeTools\\test_dats_to_merge\\current-dir\\MergedData\\</code>. With that, using the <code>pandas</code> module for Python, it is easy to recover the contents of the <code>.csv</code>.</p> <p>Expected:</p> <p>Within <code>MergeTools\\expected_csv</code> there will be a sub-directory for every test. Each of these sub-directories will be named with the prefix <code>expected_</code> followed by the <code>Merge Directory (-d)</code> name. (Ex: with \"-d test_dats_to_merge/ref_dir\" the expected csv will be found at <code>MergeTools\\expected_csv\\expected_ref_dir\\</code>). These directories and their contents must be prepared prior to testing, as these  <code>.csv</code> files' are recovered using <code>pandas</code> as well.</p> <p>With both the results and expected results in the testing program, the contents of both <code>.csv</code> files will be compared. In order for the <code>MergeTool()</code> function to pass the test, it must produce a <code>.csv</code> file that is exactly the same as the corresponding file found in <code>expected_csv</code>.</p> <p>Note: For streamlined testing, <code>MergedData</code> is completely removed after each test case. This ensures <code>test_merge.py</code> will have easy access to only the pertinent results of the current, running test case.</p>"},{"location":"metricStandards/","title":"SAE Standards","text":""},{"location":"metricStandards/#sae-standards","title":"SAE Standards","text":""},{"location":"metricStandards/#sae-j2944","title":"SAE J2944","text":"<p>The Society of Automotive Engineers <code>(SAE)</code> released a document entitled <code>Surface Vehicle Recommended Practice</code>. This document establishes a common standard for the \"Operational Definitions of Driving Performance Measures and Statistics\". The aformentioned document is tagged by SAE as <code>J2944</code>. From here forth, this tag will serve as the document's name: <code>SAE J2944</code>.</p>"},{"location":"metricStandards/#application-to-pydre","title":"Application to Pydre","text":"<p>With the standards that <code>SAE J2944</code> sets forth, the applicable metrics from Pydre should conform to each of their respective, predetermined requirements. Below, there is a list of all mentioned metrics and each of their requirements. With that, there are some metrics in Pydre that collect specialized data or perform simple statistics calculations. These metrics are not specificied in <code>SAE J2944</code>. For these situations, the metrics are omitted from the list below with the understanding that fundamental research standards are employed at all times during studies.</p>"},{"location":"metricStandards/#pydre-metrics-conform-to-sae-j2944-standards","title":"Pydre Metrics Conform to SAE J2944 Standards","text":"<p>This section will enumerate every applicable metric found within Pydre, show their requirements per SAE J2944, and expound on said requirements with any relevant notes.</p> <ol> <li> <p>Steering Entropy</p> <ul> <li>Requirements from <code>SAE J2944 - 9.2.1</code>:<ul> <li>\"The first instance the term steering entropy is used in a document, the calculation method (1999 or 2005) shall be reported.  If other computation methods are used, a link to the source code should be provided.\"</li> </ul> </li> <li>Since it uses Boer's 1999 method for calculating steering entropy, the metrics.py function, <code>steeringMetric()</code>, adheres to the standards from SAE J2944.</li> </ul> </li> <li> <p>Tailgating Time</p> <ul> <li>Requirements from <code>SAE J2944 - 8.1.4</code>:<ul> <li>\"... the two vehicles in the measurement, the common external feature (option A, B, or C), and the value above which time headway is ignored, if any, shall be reported.  The method for sensing the time separation shall also be reported.\"</li> </ul> </li> <li>Like many other metrics omitted from this list, how SimCreator collects data is something that the experimenter has limited control over. Despite no guidelines for tailgating, <code>SAE J2944</code> does mention <code>time headway</code> calculations between a subject and a lead car. The requirements, however, only address the need for measurements to be based on a consistent external feature present on both vehicles, the threshold for tailgating/ following, and the method for time sensing. With that, these measurements are collected by SimCreator and are not included within the <code>Pydre</code> program. </li> </ul> </li> <li> <p>Lane Position</p> <ul> <li><code>SDLP</code> (Standard Deviation of Lane Position)<ul> <li>Requirements from <code>SAE J2944 - 10.1.3</code>:<ul> <li>\"... the denominator term (N or N-1), the option used to compute the mean (option A, B, or C), the reference point on the vehicle used to determine lateral lane position (1 - lateral midpoint of front bumper, 2 - center of the vehicle front axle, 3 - center of gravity, 4 - spatial center), the time or distance in front of the vehicle bumper (if vehicle position is predicted), and the test condition(s) and/or independent variables over which the mean was determined (e.g., conditions, subjects, etc.) shall be reported.\"</li> </ul> </li> <li>Metrics.py() uses <code>numpy</code> for statistics calculations.</li> </ul> </li> <li><code>Mean Lane Position</code><ul> <li>Requirements from <code>SAE J2944 - 10.1.2</code>:<ul> <li>\"... the method used to calculate lane position (option A, B, or C) and the reference point on the vehicle (1 - lateral midpoint of front bumper, 2 - center of the vehicle front axle, 3 - center of gravity, or 4 - spatial center) shall be reported.\"</li> </ul> </li> <li>The point by which SimCreator calculates following distances is consistent and not within the scope of metrics.py. This is the case for many speed and time-based metrics. See <code>2. Tailgating Time</code> above for more information.</li> </ul> </li> </ul> </li> <li> <p>Brake Jerk</p> <ul> <li>Calculation guidance from <code>SAE J2944 - 7.2.13</code>:<ul> <li>\"Jerk is the time derivative of acceleration and is positive if the vehicle is accelerating, negative if decelerating. ... For driving simulators, vehicle speed is a default measure, and longitudinal acceleration may be available directly or be determined by differentiation of the speed signal.\"</li> </ul> </li> <li>Within metrics.py, the function <code>brakeJerk()</code> is supplied longitudinal acceleration and time. With those two data frames, the function calculates the time derivative of long. acceleration using numpy's gradient() function.</li> </ul> </li> <li> <p>Reaction Time</p> <ul> <li>Definition from <code>SAE J2944 - 6.5.2</code>:<ul> <li>\"Time interval, usually measured in seconds or milliseconds, from onset of an initiating event to the first observable response to that event, such as a movement of the driver\u2019s hand (on the steering wheel) or foot (on a pedal or from the floor), or, the beginning or end of an utterance by the driver (for voice-activated controls).\"</li> </ul> </li> <li>All metric functions that consider reaction time within metrics.py (such as <code>tbiReaction()</code> and <code>ecocar()</code>) have initiating events tracked in the form of Activation values that read as 1- if the reaction time is being considered- or 0- if it is not. This qualifies as an initiating event, as decribed in SAE's definition of reaction time. While the first observable response varies for each of these functions, SAE does not specify any parameters for this category.</li> </ul> </li> </ol>"},{"location":"metrics/","title":"pydre/metrics.py","text":"<p>Contains all functions for getting data metrics out of the DraveData DataFrames. The functions that are defined in the json projectfile are called from during project.py's run function.  Each metric takes in a DriveData obejct, processes it, and returns the value of the metric. Currently, the following functions are implemented (with additional arguments described beneath):</p> <ul> <li><code>meanVelocity(data, cutoff)</code> <ul> <li>data: the DriveData to be analyzed.</li> <li>cutoff: the minimum velocity to be counted in the average</li> </ul> </li> <li><code>steeringEntropy(data)</code><ul> <li>data: the DriveData to be analyzed.</li> </ul> </li> <li><code>tailgatingTime(data, cutoff = 2)</code><ul> <li>data: the DriveData to be analyzed.</li> <li>cutoff: The largest value of headway time (in seconds) that counts as tailgating.</li> </ul> </li> <li><code>tailgatingPercentage(data, cutoff = 2)</code><ul> <li>data: the DriveData to be analyzed.</li> <li>cutoff: The largest value of headway time (in seconds) that counts as tailgating.</li> </ul> </li> <li><code>brakeJerk(data, cutoff = 0)</code><ul> <li>data: the DriveData to be analyzed.</li> <li>cutoff: Smallest amount of jerk to be counted</li> </ul> </li> <li><code>boxMetrics(data, cutoff = 0, stat = \"count\")</code><ul> <li>data: the DriveData to be analyzed.</li> <li>cutoff: Smallest amount of jerk to be counted</li> <li>stat: statistic to compute, either \"count\" for the number of times the participant identified the box within 2 seconds, \"mean\" for their mean reaction time, or \"sd\" for the standard deviation of their reaction time. Used for Anna's hearing impaired study.</li> </ul> </li> </ul>"},{"location":"pydre_run/","title":"pydre_run.py","text":"<p>This script is a front end application that allows the user to analyze data using command line arguments.</p> <p>The user must enter the path for the project file and data file in order to aggregate the data. The user has the option of specifying an output file name, to which the test results will be saved. If no output file name is given the output will save to \"out.csv\" by default. A brief description of the aforementioned arguments is offered below.</p> <p>Command Line Arguments:</p> <ul> <li>Project File [-p]: The project file specifies a file for the regions of interest from which the data should be aggregated. It also specifies a list of metrics (the type of data) that will be aggregated from the regions of interest. </li> <li>Data File [-d]: The data file contains the raw metrics obtained from the simulation.</li> <li>Ouput File [-o]: After the script has executed, the output file will display the aggregated metrics from the regions of interests that were both specified in the project file. The output file will be saved in the same folder as the script. </li> <li>Logger level [-l]: This defines the level the logger will print out. The dafault is 'Warning'. Options include debug, info, warning, error, and critical.</li> </ul> <p>Command Line Syntax: <code>python pydre_run.py -p [project file path] -d [data file path] -o [output file name] -l [warning level]</code></p> <p>Example execution:  'python pydre_run.py -p C:\\Users\\pveith\\Documents\\pydre\\docs\\bioptics.json -d C:\\Users\\pveith\\Documents\\bioptics\\pydreDataSet*.dat -o bioptics.csv -l debug'</p> <p>For additional assistance while running the script use the help command (-h)</p>"},{"location":"rois/","title":"Regions of Interest","text":""},{"location":"rois/#regions-of-interest-rois","title":"Regions of Interest (ROIs)","text":"<p>Each region of interest is an area of data that the user is interested in examining. This can include things such as where the car starts on the track, when the car hits a traffic jam, when the car hits construction, etc. </p>"},{"location":"rois/#roi-csv-file-formats","title":"ROI CSV File Formats","text":"<p>For analysis, it is often useful to define ROIs in the data.  Pydre uses csv files to define spatial and temporal ROIs. The spatial regions are defined over the scenario course, while the temporal regions are defined per subject.</p>"},{"location":"rois/#time-roi-table-format","title":"Time ROI table format","text":"Subject ROI name 1 ROI name 2 ... ROI name N 1 time range time range ... time range 2 time range time range ... time range ... ... ... ... ... N time range time range ... time range <p>NOTE: Time Ranges are formatted as <code>hh:mm:ss-hh:mm:ss#driveID</code> If multiple drives are used in a particular ROI, simply add a space and write in another time range in the same cell.</p>"},{"location":"rois/#space-roi-table-format","title":"Space ROI table format","text":"ROI X1 Y1 X2 Y2 ROI name min x min y max x max y ROI name min x min y max x max y ... ... ... ... ... ROI name min x min y max x max y <p>Note: -Z corresponds to positive X, and if Y is 0 in the WRL file, set Y1 = -100, Y2 = 100.</p> <p>The ROI will consist of the area inside the max_y - min_y and the max_x - min_x.</p> <p>For an example file, look at spatial_rois.csv in the main pydre folder.  Once the ROI csv file has been generated, reference it in the project file (as seen in bushman_pf.json) to perform the function calculations only on the regions of interest specified by the x and y coordinates in this csv file.</p>"},{"location":"rois/#pydreroispy","title":"pydre/rois.py","text":"<p>Contains functions to read ROI csv files referenced by the project file. These functions take that ROI data and a list of drive data objects, extract the data that falls within the region, and return a new list of DriveData objects with only the pertinent information.</p>"},{"location":"rois/#timeroi__init__filename-nameprefix","title":"<code>TimeROI.__init__(filename, nameprefix=\"\")</code>","text":"<p>Creates a new Time ROI object. filename is the file containing the rois.</p>"},{"location":"rois/#timeroisplitdatalist","title":"<code>TimeROI.split(datalist)</code>","text":"<p>Grabs relevant parts of a list of DriveData objects based on the filename used to create the object.</p>"},{"location":"rois/#spaceroi__init__filename-nameprefix","title":"<code>SpaceROI.__init__(filename, nameprefix=\"\")</code>","text":"<p>Creates a new Space ROI object. filename is the file containing the rois.</p>"},{"location":"rois/#spaceroisplitdatalist","title":"<code>SpaceROI.split(datalist)</code>","text":"<p>Grabs relevant parts of a list of DriveData objects based on the filename used to create the object.</p>"}]}